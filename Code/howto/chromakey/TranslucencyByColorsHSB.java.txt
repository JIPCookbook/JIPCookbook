/*
 * Part of the Java Image Processing Cookbook, please see
 * http://www.lac.inpe.br/~rafael.santos/JIPCookbook.jsp
 * for information on usage and distribution.
 * Rafael Santos (rafael.santos@lac.inpe.br)
 */
package howto.chromakey;

import java.awt.Color;
import java.awt.image.BufferedImage;
import java.awt.image.WritableRaster;
import java.io.File;
import java.io.IOException;

import javax.imageio.ImageIO;
import javax.swing.JFrame;

import com.sun.media.jai.widget.DisplayJAI;

/**
 * This class demonstrates how to select a color for translucency. It reads two images from the disk,
 * drawing the second one over the first one but considering green pixels on the second one as
 * transparent/translucent -- the closer the color is to green, the more transparent it is.
 * In this example, the similarity to green will be calculated using the hue coordinate (HSB color
 * space).
 */
public class TranslucencyByColorsHSB
  {
  /**
   * @param args the arguments for the application (will be ignored)
   * @throws IOException 
   */
  public static void main(String[] args) throws IOException
    {
    // Read the input images. We assume that the first image is the background, and that it is larger
    // than the second image.
    BufferedImage background = ImageIO.read(new File("dsc00099_large.jpg"));
    WritableRaster raster = background.getRaster();
    BufferedImage layer = ImageIO.read(new File("UFO.png"));
    int width = layer.getWidth();
    int height = layer.getHeight();
    // We will shift the overlay image over the background this amount.
    int shiftX = 72;
    int shiftY = 80;
    // Slow method: scan all input (layer) image pixels and corresponding background pixels.
    // Calculate its "greenness" and translucency and recreate the pixels' values, plotting
    // them over the background.
    int iPixel,lPixel;
    float targetHue = 1f/3f;
    float tolerance = 0.1f;
    int iRed,iGreen,iBlue,lRed,lGreen,lBlue,oRed,oGreen,oBlue;
    for(int w=0;w<width;w++)
      for(int h=0;h<height;h++)
        {
        // Background pixels.
        iPixel = background.getRGB(w+shiftX,h+shiftY);
        iRed   = (int)((iPixel&0x00FF0000)>>>16); // Red level
        iGreen = (int)((iPixel&0x0000FF00)>>>8);  // Green level
        iBlue  = (int) (iPixel&0x000000FF);       // Blue level
        // Layer pixels.
        lPixel = layer.getRGB(w,h);
        lRed   = (int)((lPixel&0x00FF0000)>>>16); // Red level
        lGreen = (int)((lPixel&0x0000FF00)>>>8);  // Green level
        lBlue  = (int) (lPixel&0x000000FF);       // Blue level
        float[] lHSB = Color.RGBtoHSB(lRed,lGreen,lBlue,null);
        // Calculate the translucency, based on the green value of the layer, using HSB coordinates.
        // To make calculations easier, let's assume that the translucency is a value between 0 
        // (invisible) and 1 (opaque).
        float deltaHue = Math.abs(lHSB[0]-targetHue);
        float translucency = (deltaHue/tolerance);
        translucency = Math.min(translucency,1f);
        // Recalculate the RGB coordinates of the layer and background pixels, using the translucency
        // as a weight.
        oRed = (int)(translucency*lRed+(1-translucency)*iRed);
        oGreen = (int)(translucency*lGreen+(1-translucency)*iGreen);
        oBlue = (int)(translucency*lBlue+(1-translucency)*iBlue);
        // Set the pixel on the output image's raster.
        raster.setPixel(w+shiftX,h+shiftY,new int[]{oRed,oGreen,oBlue,255});        
        } // end for
    // Save the image as a PNG via ImageIO.
    ImageIO.write(background,"PNG",new File("translucencyHSB.png"));
    // Display the input and output images.
    JFrame frame = new JFrame("Translucency by Colors (HSB)");    
    frame.add(new DisplayJAI(background));
    frame.pack();
    frame.setVisible(true);
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    }
  
  }
